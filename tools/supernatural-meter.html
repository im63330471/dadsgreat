<!--
Features confirmed:
	•	Single HTML file
	•	Dark matrix style (black background, glowing green text)
	•	3 screens with fade transitions
	•	Saves keyword / value / colorscheme in localStorage (auto-load on next visit)
	•	Mobile first (camera input preferred)
	•	Image → center-cropped & resized to 1024×1024 via canvas
	•	Big glowing red circular button + hazard stripes frame
	•	Vertical segmented progress bar (small rectangles) with stepped gradient
	•	Anime.js for:         • vertical bar filling (2 seconds)         • number counting up + color changing
	•	Special 101 messages (random from 5 funny variants)
        Planned funny 101 messages (one will be chosen randomly):
    	1	“OVER 9000!!! Reality just gave up.”
    	2	“METER MELTDOWN! The universe is filing a complaint.”
    	3	“101% → Calibration error: you’re too powerful for this dimension.”
    	4	“DANGER: [keyword] singularity detected. Run.”
    	5	“ERROR 101: Insufficient universe to contain this level.”
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Supernatural Meter</title>
  
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  
  <!-- Anime.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script>
  
  <style>
    body {
      background-color: #000;
      color: #0f0;
      font-family: 'Courier New', Courier, monospace;
      overflow-x: hidden;
    }
    
    .container-main {
      max-width: 480px;
      margin: 0 auto;
      padding: 20px;
    }
    
    h1, h2 {
      text-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
      letter-spacing: 2px;
    }
    
    .screen {
      position: absolute;
      inset: 0;
      opacity: 0;
      transition: opacity 0.8s ease-in-out;
      pointer-events: none;
    }
    
    .screen.active {
      opacity: 1;
      pointer-events: all;
    }
    
    .glow-button {
      width: 140px;
      height: 140px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ff4040, #c00000 40%, #800000);
      border: 5px solid #fff;
      box-shadow: 
        0 0 30px #ff0000,
        0 0 60px #ff0000,
        inset 0 0 20px #ff4040;
      animation: pulse 1.8s infinite alternate;
      position: relative;
      margin: 40px auto;
      cursor: pointer;
    }
    
    .glow-button.pressed {
      animation: none;
      background: #400000;
      box-shadow: none;
    }
    
    .hazard-frame {
      position: absolute;
      inset: -20px;
      border: 8px solid transparent;
      background: repeating-linear-gradient(
        45deg,
        #ff0 0,
        #ff0 10px,
        #000 10px,
        #000 20px
      );
      border-image: repeating-linear-gradient(45deg, #000 0, #000 4px, transparent 4px, transparent 8px) 8;
      pointer-events: none;
      border-radius: 50%;
    }
    
    #preview {
      width: 100%;
      aspect-ratio: 1/1;
      object-fit: cover;
      border: 3px solid #0f0;
      box-shadow: 0 0 15px #0f0;
      background: #111;
    }
    
    .meter-container {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 20px;
      flex-wrap: wrap;
    }
    
    .photo-frame {
      width: 75%;
      max-width: 360px;
      position: relative;
    }
    
    .vertical-meter {
      width: 60px;
      height: 75vw;
      max-height: 360px;
      background: #111;
      border: 3px solid #0f0;
      box-shadow: 0 0 12px #0f0;
      overflow: hidden;
      position: relative;
    }
    
    .segment {
      position: absolute;
      left: 0;
      right: 0;
      height: 4px;
      background: #333;
    }
    
    .fill-segment {
      height: 100%;
      width: 100%;
      position: absolute;
      bottom: 0;
      transform: scaleY(0);
      transform-origin: bottom;
    }
    
    #result-number {
      font-size: 4.5rem;
      font-weight: bold;
      text-shadow: 0 0 20px currentColor;
      text-align: center;
      margin: 30px 0;
    }
    
    @keyframes pulse {
      from { box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000; }
      to   { box-shadow: 0 0 40px #ff4040, 0 0 80px #ff4040; }
    }
    
    .fade-enter-active, .fade-leave-active {
      transition: opacity 0.8s ease;
    }
  </style>
</head>
<body>

<div class="container-main position-relative">

  <!-- ── Screen 1 ── Setup ─────────────────────────────── -->
  <div id="screen1" class="screen d-flex flex-column justify-content-center">
    <h1 class="text-center mb-5">SUPERNATURAL METER</h1>
    
    <div class="mb-4">
      <label class="form-label fs-4">Phenomenon to measure:</label>
      <input type="text" id="keyword" class="form-control form-control-lg bg-dark text-success border-success" 
             placeholder="e.g. Naughtiness" value="Naughtiness">
    </div>
    
    <div class="mb-4">
      <label class="form-label fs-4">Power Level (0–101):</label>
      <input type="range" id="level" class="form-range" min="0" max="101" step="1" value="50">
      <div class="text-center fs-3 mt-2" id="levelDisplay">50</div>
    </div>
    
    <div class="mb-5">
      <label class="form-label fs-4">Color Direction:</label>
      <div class="d-flex gap-4 justify-content-center">
        <div class="form-check form-check-inline">
          <input class="form-check-input" type="radio" name="scheme" id="greenRed" value="gr" checked>
          <label class="form-check-label" for="greenRed">Green → Red</label>
        </div>
        <div class="form-check form-check-inline">
          <input class="form-check-input" type="radio" name="scheme" id="redGreen" value="rg">
          <label class="form-check-label" for="redGreen">Red → Green</label>
        </div>
      </div>
    </div>
    
    <button class="btn btn-success btn-lg w-100 py-3 fs-4" onclick="goToScreen(2)">
      CONTINUE
    </button>
  </div>

  <!-- ── Screen 2 ── Photo & Launch ─────────────────────── -->
  <div id="screen2" class="screen d-none flex-column justify-content-center align-items-center">
    <h2 id="meterTitle" class="text-center mb-5"></h2>
    
    <div class="mb-4 w-100 text-center">
      <label class="form-label fs-4">Capture your target:</label>
      <input type="file" id="photoInput" accept="image/*" capture="environment" style="display:none"/>
      <div id="previewContainer" class="mx-auto" style="max-width:85%">
        <img id="preview" src="" alt="Preview" style="display:none"/>
        <div id="placeholder" class="bg-dark border border-success d-flex align-items-center justify-content-center" 
             style="width:100%;aspect-ratio:1/1;">
          <span class="text-muted">Tap to take photo</span>
        </div>
      </div>
    </div>
    
    <div class="position-relative">
      <div class="glow-button" id="activateBtn"></div>
      <div class="hazard-frame"></div>
    </div>
  </div>

  <!-- ── Screen 3 ── Result ─────────────────────────────── -->
  <div id="screen3" class="screen d-none d-flex flex-column justify-content-center">
    <h2 class="text-center mb-4" id="resultText"></h2>
    
    <div class="meter-container">
      <div class="photo-frame">
        <img id="resultPhoto" class="img-fluid" alt="Target"/>
      </div>
      <div class="vertical-meter">
        <div id="meterFill"></div>
      </div>
    </div>
    
    <div id="resultNumber">0</div>
  </div>

</div>

<script>
// ──────────────────────────────────────────────────────────────
// Global state & localStorage
// ──────────────────────────────────────────────────────────────

const STORAGE_KEY = "supernatural-meter-state";

let state = {
  keyword: "Naughtiness",
  level: 50,
  scheme: "gr"   // "gr" → green→red    "rg" → red→green
};

function loadState() {
  const saved = localStorage.getItem(STORAGE_KEY);
  if (saved) {
    Object.assign(state, JSON.parse(saved));
  }
}

function saveState() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

// ──────────────────────────────────────────────────────────────
// Color gradient helpers
// ──────────────────────────────────────────────────────────────

function getColorGradient(percent, scheme = state.scheme) {
  const p = Math.min(1, Math.max(0, percent / 100));
  
  if (scheme === "gr") {
    // green → yellow → red
    if (p < 0.5) {
      // green → yellow
      const t = p * 2;
      return `rgb(${Math.round(0   + 255*t)}, ${Math.round(255 - 100*t)}, 0)`;
    } else {
      // yellow → red
      const t = (p - 0.5) * 2;
      return `rgb(255, ${Math.round(155 - 155*t)}, 0)`;
    }
  } else {
    // red → yellow → green
    if (p < 0.5) {
      // red → yellow
      const t = p * 2;
      return `rgb(255, ${Math.round(0 + 155*t)}, 0)`;
    } else {
      // yellow → green
      const t = (p - 0.5) * 2;
      return `rgb(${Math.round(255 - 255*t)}, 255, 0)`;
    }
  }
}

// ──────────────────────────────────────────────────────────────
// Screen management
// ──────────────────────────────────────────────────────────────

function goToScreen(n) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  const target = document.getElementById(`screen${n}`);
  target.classList.add('active');
  
  if (n === 2) initScreen2();
  if (n === 3) startResultAnimation();
}

function initScreen1() {
  document.getElementById('keyword').value = state.keyword;
  document.getElementById('level').value = state.level;
  document.getElementById('levelDisplay').textContent = state.level;
  document.querySelector(`input[name="scheme"][value="${state.scheme}"]`).checked = true;
}

function initScreen2() {
  state.keyword = document.getElementById('keyword').value.trim() || "Mystery";
  state.level = parseInt(document.getElementById('level').value);
  state.scheme = document.querySelector('input[name="scheme"]:checked').value;
  
  saveState();
  
  document.getElementById('meterTitle').textContent = `${state.keyword} Meter`;
  
  const btn = document.getElementById('activateBtn');
  btn.onclick = () => {
    if (!document.getElementById('preview').src || document.getElementById('preview').src.includes('placeholder')) {
      alert("Please take a photo first!");
      return;
    }
    btn.classList.add('pressed');
    setTimeout(() => goToScreen(3), 400);
  };
  
  // Photo input
  const input = document.getElementById('photoInput');
  const preview = document.getElementById('preview');
  const placeholder = document.getElementById('placeholder');
  
  document.getElementById('previewContainer').onclick = () => input.click();
  
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = ev => {
      const img = new Image();
      img.onload = () => {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        
        // Center crop to square
        const size = Math.min(img.width, img.height);
        const sx = (img.width - size)/2;
        const sy = (img.height - size)/2;
        
        ctx.drawImage(img, sx, sy, size, size, 0, 0, 1024, 1024);
        
        preview.src = canvas.toDataURL('image/jpeg', 0.92);
        preview.style.display = 'block';
        placeholder.style.display = 'none';
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  };
}

function startResultAnimation() {
  const percent = state.level;
  const photo = document.getElementById('resultPhoto');
  photo.src = document.getElementById('preview').src;
  
  // Special 101 messages
  let displayText = `The ${state.keyword} level detected is ${percent}%`;
  
  if (percent === 101) {
    const messages = [
      "OVER 9000!!! Reality just gave up.",
      "METER MELTDOWN! The universe is filing a complaint.",
      "101% → Calibration error: you're too powerful for this dimension.",
      "DANGER: " + state.keyword + " singularity detected. Run.",
      "ERROR 101: Insufficient universe to contain this level."
    ];
    displayText = messages[Math.floor(Math.random() * messages.length)];
  }
  
  document.getElementById('resultText').textContent = displayText;
  
  // Build segmented meter (stepped look)
  const fill = document.getElementById('meterFill');
  fill.innerHTML = '';
  
  const steps = 80; // number of small segments
  for(let i = 0; i < steps; i++) {
    const seg = document.createElement('div');
    seg.className = 'segment fill-segment';
    seg.style.bottom = (i / steps * 100) + '%';
    seg.style.height = (100 / steps) + '%';
    seg.style.background = getColorGradient((i / steps) * 100);
    seg.style.transform = 'scaleY(0)';
    fill.appendChild(seg);
  }
  
  // Anime.js animations
  anime.timeline({
    easing: 'easeOutQuad',
    duration: 2000
  })
  // Fill meter
  .add({
    targets: '.fill-segment',
    scaleY: [0, 1],
    duration: 1800,
    delay: anime.stagger(20, {from: 'first'})
  })
  // Count number + color change
  .add({
    targets: '#resultNumber',
    innerHTML: [0, percent],
    round: 1,
    duration: 2000,
    update: function(anim) {
      const val = Math.round(anim.animatables[0].target.innerHTML);
      anim.animatables[0].target.style.color = getColorGradient(val);
    }
  }, '-=1800');
}

// ──────────────────────────────────────────────────────────────
// Init
// ──────────────────────────────────────────────────────────────

loadState();
initScreen1();
goToScreen(1);

// Update slider display live
document.getElementById('level').addEventListener('input', e => {
  document.getElementById('levelDisplay').textContent = e.target.value;
});
</script>
</body>
</html>

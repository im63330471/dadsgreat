<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Read & Match - Color Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f9ff;
            font-family: 'Comic Sans MS', cursive, sans-serif;
        }
        canvas {
            display: block;
            margin: 0 auto;
        }
        .dark {
            background-color: #181818;
        }
    </style>
</head>
<body>
    <script>
        // Game variables
        let sentences = [
            {text: "The apple is", correctColor: "red"},
            {text: "The banana is", correctColor: "yellow"},
            {text: "The grass is", correctColor: "green"},
            {text: "The sky is", correctColor: "blue"},
            {text: "The sun is", correctColor: "yellow"},
            {text: "The orange is", correctColor: "orange"},
            {text: "The grapes are", correctColor: "purple"},
            {text: "The clouds are", correctColor: "white"}
        ];
        
        let colors = [
            {name: "red", value: "#FF5555"},
            {name: "blue", value: "#5555FF"},
            {name: "green", value: "#55AA55"},
            {name: "yellow", value: "#FFFF55"},
            {name: "purple", value: "#AA55AA"},
            {name: "orange", value: "#FFAA55"},
            {name: "white", value: "#FFFFFF"}
        ];
        
        let currentSentence;
        let colorOptions = [];
        let score = 0;
        let maxScore = 0;
        let feedback = "";
        let feedbackColor = "#000000";
        let showingFeedback = false;
        let feedbackTimer = 0;
        let stars = [];
        let gameStarted = false;
        let gameComplete = false;
        let characterImages = {};
        let darkMode = false;
        
        function preload() {
            // We'll create icons programmatically instead of loading images
        }
        
        function setup() {
            // Create canvas that fills most of the screen but maintains aspect ratio
            let canvasSize = min(windowWidth * 0.95, windowHeight * 0.95);
            createCanvas(canvasSize, canvasSize);
            textAlign(CENTER, CENTER);
            
            // Check for dark mode
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                darkMode = true;
                document.body.classList.add('dark');
            }
            
            // Initialize stars for celebration
            for (let i = 0; i < 50; i++) {
                stars.push({
                    x: random(width),
                    y: random(height),
                    size: random(10, 30),
                    speed: random(2, 5),
                    color: random(colors).value,
                    rotation: random(TWO_PI),
                    rotSpeed: random(-0.1, 0.1)
                });
            }
            
            // Add listener for dark mode changes
            if (window.matchMedia) {
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                    darkMode = event.matches;
                    if (darkMode) {
                        document.body.classList.add('dark');
                    } else {
                        document.body.classList.remove('dark');
                    }
                });
            }
        }
        
        function draw() {
            // Set background color based on mode
            background(darkMode ? "#181818" : "#f0f9ff");
            
            if (!gameStarted) {
                displayStartScreen();
                return;
            }
            
            if (gameComplete) {
                displayCompleteScreen();
                return;
            }
            
            // Display score stars
            let starSize = width * 0.05;
            let starSpacing = starSize * 1.2;
            let totalWidth = score * starSpacing;
            let startX = (width - totalWidth) / 2 + starSpacing / 2;
            
            textSize(24);
            fill(darkMode ? "#FFFFFF" : "#333333");
            text("Stars:", width / 2, 30);
            
            for (let i = 0; i < score; i++) {
                let x = startX + i * starSpacing;
                drawStar(x, 70, starSize/4, starSize/2, 5, "#FFD700");
            }
            
            // Display current sentence
            textSize(min(36, width / 18));
            fill(darkMode ? "#FFFFFF" : "#333333");
            text(currentSentence.text + " _____", width / 2, height * 0.4);
            
            // Display color options
            let optionSize = min(width / 8, height / 10);
            let maxOptions = min(4, colorOptions.length);
            let optionsStartX = width / 2 - ((maxOptions * optionSize) + (maxOptions - 1) * (width * 0.03)) / 2;
            
            for (let i = 0; i < colorOptions.length; i++) {
                let x = optionsStartX + i * (optionSize + width * 0.03);
                let y = height * 0.65;
                
                // Draw color swatch
                fill(colorOptions[i].value);
                stroke(darkMode ? "#FFFFFF" : "#000000");
                strokeWeight(2);
                rect(x, y, optionSize, optionSize, 10);
                
                // Draw color name with background for better visibility
                // Background for text
                let textBgColor = darkMode ? "#222222" : "#FFFFFF";
                let textFgColor = darkMode ? "#FFFFFF" : "#000000";
                
                // Special case for white and yellow in light mode
                if (!darkMode && (colorOptions[i].name === "white" || colorOptions[i].name === "yellow")) {
                    textBgColor = "#555555";
                    textFgColor = "#FFFFFF";
                }
                
                let nameWidth = optionSize * 1.2;
                let nameHeight = optionSize * 0.3;
                
                // Text background
                fill(textBgColor);
                strokeWeight(1);
                stroke(darkMode ? "#444444" : "#CCCCCC");
                rect(x + optionSize/2 - nameWidth/2, y + optionSize + 10, 
                     nameWidth, nameHeight, 5);
                
                // Text
                fill(textFgColor);
                noStroke();
                textSize(min(20, optionSize / 4));
                textStyle(BOLD);
                text(colorOptions[i].name, x + optionSize / 2, y + optionSize + 10 + nameHeight/2);
                textStyle(NORMAL);
            }
            
            // Display feedback
            if (showingFeedback) {
                textSize(min(40, width / 15));
                fill(feedbackColor);
                text(feedback, width / 2, height * 0.85);
                
                feedbackTimer++;
                if (feedback === "Correct!") {
                    displayCelebration();
                }
                
                if (feedbackTimer > 60) { // Show feedback for 1 second (60 fps)
                    showingFeedback = false;
                    feedbackTimer = 0;
                    
                    // If answer was correct, move to next question
                    if (feedback === "Correct!") {
                        if (score >= sentences.length) {
                            gameComplete = true;
                        } else {
                            setupNewQuestion();
                        }
                    }
                }
            }
        }
        
        function drawObject(x, y, size) {
            // Draw a simple representation of the object based on the current sentence
            push();
            translate(x, y);
            
            let objectName = currentSentence.text.toLowerCase();
            
            if (objectName.includes("apple")) {
                // Draw apple
                fill("#FF5555"); // Red
                noStroke();
                ellipse(0, 0, size, size);
                
                // Stem
                fill("#55AA55"); // Green
                rect(-size/20, -size/2, size/10, size/6, 2);
                
                // Leaf
                fill("#55AA55"); // Green
                ellipse(size/10, -size/2 + size/10, size/6, size/10);
            } 
            else if (objectName.includes("banana")) {
                // Draw banana
                fill("#FFFF55"); // Yellow
                noStroke();
                arc(0, 0, size, size/1.5, PI*0.2, PI*1.8, CHORD);
            }
            else if (objectName.includes("grass")) {
                // Draw grass
                fill("#55AA55"); // Green
                noStroke();
                rect(-size/2, -size/4, size, size/2, 5, 5, 0, 0);
                
                // Grass blades
                for (let i = -4; i <= 4; i++) {
                    let x = (i * size/10);
                    triangle(x, -size/4, x+size/40, -size/1.5, x+size/20, -size/4);
                }
            }
            else if (objectName.includes("sky")) {
                // Draw sky with clouds
                fill("#5555FF"); // Blue
                noStroke();
                rect(-size/2, -size/2, size, size, 5);
                
                // Clouds
                fill("#FFFFFF");
                ellipse(-size/4, -size/4, size/3, size/4);
                ellipse(-size/6, -size/3, size/4, size/3);
                ellipse(size/4, -size/5, size/3, size/5);
            }
            else if (objectName.includes("sun")) {
                // Draw sun
                fill("#FFFF55"); // Yellow
                noStroke();
                ellipse(0, 0, size, size);
                
                // Sun rays
                for (let i = 0; i < 8; i++) {
                    let angle = i * PI/4;
                    line(cos(angle)*size/2, sin(angle)*size/2, 
                         cos(angle)*size*0.8, sin(angle)*size*0.8);
                }
            }
            else if (objectName.includes("orange")) {
                // Draw orange
                fill("#FFAA55"); // Orange
                noStroke();
                ellipse(0, 0, size, size);
                
                // Stem/leaf
                fill("#55AA55"); // Green
                ellipse(0, -size/2 + size/8, size/8, size/4);
            }
            else if (objectName.includes("grapes")) {
                // Draw grapes
                fill("#AA55AA"); // Purple
                noStroke();
                
                // Cluster of grapes
                for (let i = -1; i <= 1; i++) {
                    for (let j = 0; j <= 2; j++) {
                        ellipse(i*size/4, j*size/4, size/4, size/4);
                    }
                }
                
                // Stem
                fill("#55AA55"); // Green
                rect(-size/20, -size/2, size/10, size/5, 2);
            }
            else if (objectName.includes("clouds")) {
                // Draw clouds
                fill("#FFFFFF");
                noStroke();
                ellipse(-size/3, 0, size/2, size/3);
                ellipse(0, -size/6, size/2, size/2);
                ellipse(size/3, 0, size/3, size/4);
            }
            
            pop();
        }
        
        function displayStartScreen() {
            // Title
            textSize(min(50, width / 12));
            fill(darkMode ? "#FFFFFF" : "#333333");
            text("Read & Match", width / 2, height * 0.3);
            
            // Instructions
            textSize(min(24, width / 25));
            text("Match the correct color to complete the sentence", width / 2, height * 0.45);
            
            // Draw colorful characters
            let characterSize = width * 0.1;
            let startX = width * 0.2;
            
            for (let i = 0; i < 5; i++) {
                let x = startX + i * (characterSize * 1.5);
                let color = colors[i % colors.length].value;
                drawFriendlyCharacter(x, height * 0.6, characterSize, color);
            }
            
            // Start button
            let buttonWidth = width * 0.4;
            let buttonHeight = height * 0.1;
            let buttonX = width / 2 - buttonWidth / 2;
            let buttonY = height * 0.75;
            
            fill("#5D5CDE");
            stroke(darkMode ? "#FFFFFF" : "#000000");
            strokeWeight(3);
            rect(buttonX, buttonY, buttonWidth, buttonHeight, 15);
            
            fill("#FFFFFF");
            noStroke();
            textSize(min(30, buttonHeight * 0.6));
            text("START", width / 2, buttonY + buttonHeight / 2);
            
            // Check if start button is clicked
            if (mouseIsPressed && 
                mouseX > buttonX && mouseX < buttonX + buttonWidth &&
                mouseY > buttonY && mouseY < buttonY + buttonHeight) {
                gameStarted = true;
                setupNewQuestion();
            }
        }
        
        function drawFriendlyCharacter(x, y, size, color) {
            push();
            translate(x, y);
            
            // Body
            fill(color);
            noStroke();
            ellipse(0, 0, size, size * 1.2);
            
            // Eyes
            fill("#FFFFFF");
            ellipse(-size/5, -size/6, size/4, size/4);
            ellipse(size/5, -size/6, size/4, size/4);
            
            // Pupils
            fill("#000000");
            ellipse(-size/5, -size/6, size/8, size/8);
            ellipse(size/5, -size/6, size/8, size/8);
            
            // Smile
            noFill();
            stroke("#000000");
            strokeWeight(size/20);
            arc(0, size/8, size/2, size/4, 0, PI);
            
            pop();
        }
        
        function displayCompleteScreen() {
            background(darkMode ? "#181818" : "#f0f9ff");
            
            // Display celebration
            displayCelebration();
            
            // Congratulations message
            textSize(min(50, width / 12));
            fill(darkMode ? "#FFFFFF" : "#333333");
            text("Great Job!", width / 2, height * 0.3);
            
            textSize(min(30, width / 20));
            text(`You earned ${score} stars!`, width / 2, height * 0.45);
            
            // Draw stars
            let starSize = width * 0.05;
            let starSpacing = starSize * 1.2;
            let maxStarsPerRow = 5;
            let rows = ceil(score / maxStarsPerRow);
            
            for (let i = 0; i < score; i++) {
                let row = floor(i / maxStarsPerRow);
                let col = i % maxStarsPerRow;
                
                let rowWidth = min(score - row * maxStarsPerRow, maxStarsPerRow) * starSpacing;
                let rowStartX = (width - rowWidth) / 2 + starSpacing / 2;
                
                let x = rowStartX + col * starSpacing;
                let y = height * 0.55 + row * starSpacing;
                
                drawStar(x, y, starSize/4, starSize/2, 5, "#FFD700");
            }
            
            // Play again button
            let buttonWidth = width * 0.4;
            let buttonHeight = height * 0.1;
            let buttonX = width / 2 - buttonWidth / 2;
            let buttonY = height * 0.75;
            
            fill("#5D5CDE");
            stroke(darkMode ? "#FFFFFF" : "#000000");
            strokeWeight(3);
            rect(buttonX, buttonY, buttonWidth, buttonHeight, 15);
            
            fill("#FFFFFF");
            noStroke();
            textSize(min(30, buttonHeight * 0.6));
            text("PLAY AGAIN", width / 2, buttonY + buttonHeight / 2);
            
            // Check if play again button is clicked
            if (mouseIsPressed && 
                mouseX > buttonX && mouseX < buttonX + buttonWidth &&
                mouseY > buttonY && mouseY < buttonY + buttonHeight) {
                resetGame();
            }
        }
        
        function displayCelebration() {
            // Animate stars
            for (let star of stars) {
                push();
                translate(star.x, star.y);
                rotate(star.rotation);
                drawStar(0, 0, star.size / 4, star.size / 2, 5, star.color);
                pop();
                
                star.rotation += star.rotSpeed;
                star.y += star.speed;
                if (star.y > height + star.size) {
                    star.y = -star.size;
                    star.x = random(width);
                }
            }
        }
        
        function drawStar(x, y, radius1, radius2, npoints, color) {
            let angle = TWO_PI / npoints;
            let halfAngle = angle / 2.0;
            
            fill(color);
            noStroke();
            beginShape();
            for (let a = -PI/2; a < TWO_PI-PI/2; a += angle) {
                let sx = x + cos(a) * radius2;
                let sy = y + sin(a) * radius2;
                vertex(sx, sy);
                sx = x + cos(a + halfAngle) * radius1;
                sy = y + sin(a + halfAngle) * radius1;
                vertex(sx, sy);
            }
            endShape(CLOSE);
        }
        
        function setupNewQuestion() {
            // Select a sentence that hasn't been used yet
            let availableSentences = sentences.filter((_, index) => index >= maxScore);
            if (availableSentences.length === 0) {
                gameComplete = true;
                return;
            }
            
            currentSentence = availableSentences[0];
            maxScore = max(maxScore, sentences.indexOf(currentSentence) + 1);
            
            // Set up color options (include correct color and 3 random others)
            colorOptions = [];
            
            // Add correct color
            let correctColor = colors.find(c => c.name === currentSentence.correctColor);
            colorOptions.push(correctColor);
            
            // Add random wrong colors
            let wrongColors = colors.filter(c => c.name !== currentSentence.correctColor);
            shuffleArray(wrongColors);
            
            for (let i = 0; i < min(3, wrongColors.length); i++) {
                colorOptions.push(wrongColors[i]);
            }
            
            // Shuffle options
            shuffleArray(colorOptions);
        }
        
        function mousePressed() {
            if (!gameStarted || gameComplete || showingFeedback) {
                return;
            }
            
            // Check if a color option was clicked
            let optionSize = min(width / 8, height / 10);
            let maxOptions = min(4, colorOptions.length);
            let optionsStartX = width / 2 - ((maxOptions * optionSize) + (maxOptions - 1) * (width * 0.03)) / 2;
            
            for (let i = 0; i < colorOptions.length; i++) {
                let x = optionsStartX + i * (optionSize + width * 0.03);
                let y = height * 0.65;
                
                if (mouseX >= x && mouseX <= x + optionSize &&
                    mouseY >= y && mouseY <= y + optionSize) {
                    // Color option clicked
                    checkAnswer(colorOptions[i]);
                    break;
                }
            }
        }
        
        function touchStarted() {
            // Handle touch events the same as mouse events
            mousePressed();
            // Prevent default touch behavior
            return false;
        }
        
        function checkAnswer(selectedColor) {
            showingFeedback = true;
            feedbackTimer = 0;
            
            if (selectedColor.name === currentSentence.correctColor) {
                feedback = "Correct!";
                feedbackColor = "#55AA55"; // Green
                score++;
            } else {
                feedback = "Try again!";
                feedbackColor = "#FF5555"; // Red
            }
        }
        
        function resetGame() {
            score = 0;
            maxScore = 0;
            gameComplete = false;
            setupNewQuestion();
        }
        
        // Utility functions
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function getContrastColor(hexColor) {
            // Convert hex to RGB
            let r = parseInt(hexColor.substr(1, 2), 16);
            let g = parseInt(hexColor.substr(3, 2), 16);
            let b = parseInt(hexColor.substr(5, 2), 16);
            
            // Calculate brightness
            let brightness = (r * 299 + g * 587 + b * 114) / 1000;
            
            // Return black or white based on brightness
            return brightness > 128 ? "#000000" : "#FFFFFF";
        }
        
        // Make canvas responsive
        function windowResized() {
            let canvasSize = min(windowWidth * 0.95, windowHeight * 0.95);
            resizeCanvas(canvasSize, canvasSize);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Millionaire</title>
    <link rel="stylesheet" href="../css/style.css">
    <style>
        body, * {
            font-family: 'Arial', Arial, sans-serif !important;
        }
        body {
            background: #f0f8ff;
            min-height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100vw;
            min-height: 100vh;
            justify-content: center;
            background: #2d014d;
        }
        .game-area {
            display: flex;
            flex-direction: row;
            justify-content: center;
            width: 100%;
            max-width: 700px;
        }
        .quiz-container, .ladder-container {
            background: none;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 1.5rem 1.5rem 1.5rem 1.5rem;
            margin: 0 1.5rem 1.5rem 0;
            width: 270px;
            min-height: 220px;
            text-align: left;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            border: 10px solid #b3e5fc;
        }
        .ladder-container {
            margin: 0 0 1.5rem 1.5rem;
            width: 140px;
            min-height: 220px;
        }
        .question {
            font-size: 2.2rem;
            margin-bottom: 1.2rem;
            color: #fff;
            text-align: center;
            font-family: 'Arial', Arial, sans-serif !important;
            font-weight: bold;
        }
        .answers button {
            display: block;
            width: 100%;
            margin: 0.6rem 0;
            padding: 0.6rem;
            font-size: 1.1rem;
            border-radius: 8px;
            border: none;
            background: #fff;
            color: #2d014d;
            cursor: pointer;
            transition: background 0.2s;
        }
        .answers button:disabled {
            pointer-events: none;
            opacity: 0.95;
            background: #fff !important;
            color: #2d014d !important;
            cursor: default;
        }
        .answers button.selected {
            background: #ffd600 !important;
        }
        .answers button.correct {
            background: #43a047 !important;
            color: #fff !important;
        }
        .answers button.incorrect {
            background: #d84315 !important;
            color: #fff !important;
        }
        .result {
            font-size: 1.3rem;
            color: #d84315;
            margin-top: 1.2rem;
            text-align: center;
        }
        .ladder {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .ladder li {
            font-size: 1.1rem;
            padding: 0.3rem 0.5rem;
            margin: 0.25rem 0;
            border-radius: 32px 6px 6px 32px / 50% 6px 6px 50%;
            background: #e3f2fd;
            color: #1976d2;
            text-align: right;
            font-weight: normal;
            border-left: 8px solid #fff;
            border-right: none;
            transition: background 0.2s, color 0.2s;
        }
        .ladder li.achieved {
            background: #43a047 !important; /* achieved = green */
            color: #fff !important;
            border: none
        }
        .ladder li.current {
            background: #ffd600 !important; /* current = yellow */
            color: #d84315 !important;
            font-weight: bold;
            border: none
        }
        /* safety net and million styling: same size and bold */
        .ladder li.safetynet, .ladder li.million {
            font-size: 1.25rem;
            font-weight: bold !important;
        }
        /* Remove column layout for small screens, always row */
        @media (max-width: 800px) {
            .game-area {
                flex-direction: row !important;
                align-items: flex-start;
            }
            .quiz-container, .ladder-container {
                margin: 1rem 0.5rem;
                width: 90%;
                max-width: 350px;
            }
        }
        #start-screen-title {
            color: #fff !important;
        }
        #type-form button[type=submit] {
            font-size: 1.2rem;
            background: #4fc3f7 !important;
            color: #0a2259 !important;
            border: none;
            border-radius: 8px;
            padding: 0.7rem 2.5rem;
            cursor: pointer;
            font-family: 'Arial', Arial, sans-serif !important;
            margin-top: 1.2rem;
            width: 50%;
            min-width: 120px;
            max-width: 200px;
            display: block;
            margin-left: auto;
            margin-right: auto;
            transition: background 0.2s;
        }
        #type-form button[type=submit]:hover {
            background: #1976d2 !important;
            color: #fff !important;
        }
        .answers button:hover {
            background: #ff9800 !important;
            color: #fff !important;
        }
        #final-answer-btn {
             display: block;
             margin: 2.2rem auto 0 auto !important;
             background: #4fc3f7 !important;
             color: #fff !important;
             border: none;
             border-radius: 8px;
             padding: 0.7rem 2.5rem;
             font-size: 1.2rem;
             font-family: 'Arial', Arial, sans-serif !important;
             font-weight: normal;
             cursor: pointer;
             width: 75% !important; /* wider to avoid wrapping */
             max-width: 340px; /* keep reasonable on narrow screens */
             white-space: nowrap; /* keep text on one line */
             height: auto !important;
             letter-spacing: 1px;
             transition: background 0.2s;
         }
        #final-answer-btn:hover {
            background: #1976d2 !important;
        }
        .custom-next-btn, .restart {
            margin-top: 1.2rem;
            background: #1976d2 !important;
            color: #fff !important;
            border: none !important;
            border-radius: 8px !important;
            padding: 0.7rem 2.5rem !important;
            font-size: 1.1rem !important;
            font-family: Arial, sans-serif !important;
            cursor: pointer !important;
            width: 50% !important;
            min-width: 120px;
            max-width: 200px;
            display: block;
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
            transition: background 0.2s;
        }
        /* Make Next button stand out */
        #next-btn {
            background: #ff9800 !important;
            color: #0a2259 !important;
            width: 50% !important;
            min-width: 120px;
        }
        #next-btn:hover { background: #fb8c00 !important; }
        .custom-next-btn:hover, .restart:hover {
            background: #1565c0 !important;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div id="start-screen" style="width:100vw; min-height:100vh; display:flex; flex-direction:column; align-items:center; justify-content:center;">
            <div id="start-screen-title" style="font-size:2.5rem; font-weight:bold; margin-bottom:2rem; letter-spacing:2px;">MATH MILLIONAIRE</div>
            <form id="type-form" style="border:10px solid #b3e5fc; background:transparent; border-radius:16px; box-shadow:0 2px 8px rgba(0,0,0,0.08); padding:2rem 2.5rem; display:flex; flex-direction:column; align-items:center; color:#fff;">
                <div style="font-size:1.2rem; margin-bottom:1rem; color:#fff;"><u>Choose question types:</u></div>
                <div id="checkbox-area" style="display:flex; flex-direction:column; align-items:flex-start; margin-bottom:2rem;"></div>
                <button type="submit">Start</button>
            </form>
        </div>
        <div class="game-area" id="game-area" style="display:none;">
            <div class="quiz-container">
                <div class="question" id="question"></div>
                <div class="answers" id="answers"></div>
                <div class="result" id="result"></div>
                <button class="restart" id="restart" style="display:none;">Restart</button>
            </div>
            <div class="ladder-container">
                <ul class="ladder" id="ladder"></ul>
            </div>
        </div>
        <!-- moved question type label here (below game-area) -->
        <div id="question-type-label" style="margin-top:1rem; font-size:1.1rem; text-align:center; color:#fff; width:100%; max-width:700px;"></div>
    </div>
    <script>
        const questionTypes = [
            "Total is 5, one of the number is between 1-4, ask another number",
            "Total is 10, one of the number is between 1-9, ask another number",
            "Two numbers, total is between 6-10, ask total",
            "Two numbers, total is between 11-20, ask total",
            "Total is 20, one of the number is between 1-19, ask another number",
            "Total is between 11-15, one of the number is between 1-9, ask another number",
            "Total is between 16-20, one of the number is between 6-14, ask another number",
            "First number is between 11-15, second number is between 2-6, ask the difference",
            "First number is between 16-20, second number is between 7-11, ask the difference",
            "First number is between 11-15, difference is between 2-6, ask second number",
            "First number is between 16-20, difference is between 7-11, ask second number"
        ];
        // Prize ladder
        const prizeLadder = [
            1000, 2000, 3000, 4000, 6000,
            10000, 20000, 30000, 40000, 60000,
            80000, 150000, 250000, 500000, 1000000
        ];

        // Generate question by type
        function generateQuestionByType(typeIdx) {
            switch(typeIdx) {
                case 0: {
                    // Total is 5, one number 1-4, ask another number (randomly ask for first or second)
                    const a = Math.floor(Math.random()*4)+1;
                    const b = 5 - a;
                    if (Math.random() < 0.5) {
                        // ask for first
                        const shuf = shuffleAnswers([a, ...uniqueRandoms(1,4,3,a)], a);
                        return {
                            question: `? + ${b} = 5`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    } else {
                        // ask for second
                        const shuf = shuffleAnswers([b, ...uniqueRandoms(1,4,3,b)], b);
                        return {
                            question: `${a} + ? = 5`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    }
                }
                case 1: {
                    // Total is 10, one number 1-9, ask another number (randomly ask for first or second)
                    const a = Math.floor(Math.random()*9)+1;
                    const b = 10 - a;
                    if (Math.random() < 0.5) {
                        const shuf = shuffleAnswers([a, ...uniqueRandoms(1,9,3,a)], a);
                        return {
                            question: `? + ${b} = 10`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    } else {
                        const shuf = shuffleAnswers([b, ...uniqueRandoms(1,9,3,b)], b);
                        return {
                            question: `${a} + ? = 10`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    }
                }
                case 2: {
                    const total = Math.floor(Math.random()*5)+6;
                    const a = Math.floor(Math.random()*(total-1))+1;
                    const b = total - a;
                    const shuf = shuffleAnswers([total, ...uniqueRandoms(6,10,3,total)], total);
                    return {
                        question: `${a} + ${b} = ?`,
                        answers: shuf.answers,
                        correct: shuf.correct,
                        typeIdx: typeIdx
                    };
                }
                case 3: {
                    const total = Math.floor(Math.random()*10)+11;
                    const a = Math.floor(Math.random()*(total-1))+1;
                    const b = total - a;
                    const shuf = shuffleAnswers([total, ...uniqueRandoms(11,20,3,total)], total);
                    return {
                        question: `${a} + ${b} = ?`,
                        answers: shuf.answers,
                        correct: shuf.correct,
                        typeIdx: typeIdx
                    };
                }
                case 4: {
                    const a = Math.floor(Math.random()*19)+1;
                    const b = 20 - a;
                    if (Math.random() < 0.5) {
                        const shuf = shuffleAnswers([a, ...uniqueRandoms(1,19,3,a)], a);
                        return {
                            question: `? + ${b} = 20`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    } else {
                        const shuf = shuffleAnswers([b, ...uniqueRandoms(1,19,3,b)], b);
                        return {
                            question: `${a} + ? = 20`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    }
                }
                case 5: {
                    const total = Math.floor(Math.random()*5)+11;
                    const a = Math.floor(Math.random()*9)+1;
                    let b = total - a;
                    if (b <= 0) b = 1;
                    if (Math.random() < 0.5) {
                        const shuf = shuffleAnswers([a, ...uniqueRandoms(1,9,3,a)], a);
                        return {
                            question: `? + ${b} = ${total}`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    } else {
                        const shuf = shuffleAnswers([b, ...uniqueRandoms(1,9,3,b)], b);
                        return {
                            question: `${a} + ? = ${total}`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    }
                }
                case 6: {
                    const total = Math.floor(Math.random()*5)+16;
                    const a = Math.floor(Math.random()*9)+6;
                    let b = total - a;
                    if (b <= 0) b = 1;
                    if (Math.random() < 0.5) {
                        const shuf = shuffleAnswers([a, ...uniqueRandoms(6,14,3,a)], a);
                        return {
                            question: `? + ${b} = ${total}`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    } else {
                        const shuf = shuffleAnswers([b, ...uniqueRandoms(1,14,3,b)], b);
                        return {
                            question: `${a} + ? = ${total}`,
                            answers: shuf.answers,
                            correct: shuf.correct,
                            typeIdx: typeIdx
                        };
                    }
                }
                case 7: {
                    const a = Math.floor(Math.random()*5)+11;
                    const b = Math.floor(Math.random()*5)+2;
                    const diff = a - b;
                    const shuf = shuffleAnswers([diff, ...uniqueRandoms(5,13,3,diff)], diff);
                    return {
                        question: `${a} - ${b} = ?`,
                        answers: shuf.answers,
                        correct: shuf.correct,
                        typeIdx: typeIdx
                    };
                }
                case 8: {
                    const a = Math.floor(Math.random()*5)+16;
                    const b = Math.floor(Math.random()*5)+7;
                    const diff = a - b;
                    const shuf = shuffleAnswers([diff, ...uniqueRandoms(5,13,3,diff)], diff);
                    return {
                        question: `${a} - ${b} = ?`,
                        answers: shuf.answers,
                        correct: shuf.correct,
                        typeIdx: typeIdx
                    };
                }
                case 9: {
                    const a = Math.floor(Math.random()*5)+11;
                    const diff = Math.floor(Math.random()*5)+2;
                    const b = a - diff;
                    const shuf = shuffleAnswers([b, ...uniqueRandoms(5,13,3,b)], b);
                    return {
                        question: `${a} - ? = ${diff}`,
                        answers: shuf.answers,
                        correct: shuf.correct,
                        typeIdx: typeIdx
                    };
                }
                case 10: {
                    const a = Math.floor(Math.random()*5)+16;
                    const diff = Math.floor(Math.random()*5)+7;
                    const b = a - diff;
                    const shuf = shuffleAnswers([b, ...uniqueRandoms(5,13,3,b)], b);
                    return {
                        question: `${a} - ? = ${diff}`,
                        answers: shuf.answers,
                        correct: shuf.correct,
                        typeIdx: typeIdx
                    };
                }
            }
        }
        // Helper: shuffle answers and set correct index, but sort answers ascending
        function shuffleAnswers(arr, correctValue) {
            arr = Array.from(new Set(arr)); // remove duplicates
            arr.sort((a, b) => a - b);
            return {answers: arr, correct: arr.indexOf(correctValue)};
        }
        // Helper: get unique randoms in range, excluding a value
        function uniqueRandoms(min, max, count, exclude) {
            const set = new Set();
            while (set.size < count) {
                let n = Math.floor(Math.random() * (max - min + 1)) + min;
                if (n !== exclude) set.add(n);
            }
            return Array.from(set);
        }
        // Render checkboxes
        const checkboxArea = document.getElementById('checkbox-area');
        questionTypes.forEach((label, idx) => {
            const div = document.createElement('div');
            div.style.marginBottom = '0.5rem';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.id = 'qtype' + idx;
            cb.value = idx;
            cb.style.marginRight = '0.5rem';
            div.appendChild(cb);
            const lab = document.createElement('label');
            lab.htmlFor = cb.id;
            lab.textContent = label;
            div.appendChild(lab);
            checkboxArea.appendChild(div);
        });
        // Game logic
        let questions = [];
        let current = 0;
        let score = 0;
        // Handle persistent fireworks cleanup for final-win
        let persistentFireworksCleanup = null;
        const questionEl = document.getElementById('question');
        const answersEl = document.getElementById('answers');
        const resultEl = document.getElementById('result');
        const restartBtn = document.getElementById('restart');
        const ladderEl = document.getElementById('ladder');
        const startScreen = document.getElementById('start-screen');
        const gameArea = document.getElementById('game-area');

        // Add start form handler and restart behavior
        const typeForm = document.getElementById('type-form');
        if (typeForm) {
            typeForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const checked = Array.from(document.querySelectorAll('#checkbox-area input[type=checkbox]:checked'));
                if (checked.length < 1 || checked.length > 3) {
                    alert('Please select between 1 and 3 question types.');
                    return;
                }
                // Build selected type indices
                const selectedTypes = checked.map(cb => parseInt(cb.value, 10));
                // Generate 15 questions based on selected types
                questions = [];
                const totalQuestions = 15;

                if (selectedTypes.length === 1) {
                    // All questions are of the single selected type
                    for (let i = 0; i < totalQuestions; i++) {
                        const q = generateQuestionByType(selectedTypes[0]);
                        if (q && q.typeIdx === undefined) q.typeIdx = selectedTypes[0];
                        questions.push(q);
                    }
                } else if (selectedTypes.length === 2) {
                    // First 7 questions are of the first type, next 8 are of the second type
                    for (let i = 0; i < 7; i++) {
                        const q = generateQuestionByType(selectedTypes[0]);
                        if (q && q.typeIdx === undefined) q.typeIdx = selectedTypes[0];
                        questions.push(q);
                    }
                    for (let i = 7; i < totalQuestions; i++) {
                        const q = generateQuestionByType(selectedTypes[1]);
                        if (q && q.typeIdx === undefined) q.typeIdx = selectedTypes[1];
                        questions.push(q);
                    }
                } else if (selectedTypes.length === 3) {
                    // First 5 questions are of the first type, next 5 of the second, last 5 of the third
                    for (let i = 0; i < 5; i++) {
                        const q = generateQuestionByType(selectedTypes[0]);
                        if (q && q.typeIdx === undefined) q.typeIdx = selectedTypes[0];
                        questions.push(q);
                    }
                    for (let i = 5; i < 10; i++) {
                        const q = generateQuestionByType(selectedTypes[1]);
                        if (q && q.typeIdx === undefined) q.typeIdx = selectedTypes[1];
                        questions.push(q);
                    }
                    for (let i = 10; i < totalQuestions; i++) {
                        const q = generateQuestionByType(selectedTypes[2]);
                        if (q && q.typeIdx === undefined) q.typeIdx = selectedTypes[2];
                        questions.push(q);
                    }
                }

                current = 0;
                score = 0;
                // hide start, show game
                startScreen.style.display = 'none';
                gameArea.style.display = 'flex';
                // clear any lingering label
                const typeLabelEl = document.getElementById('question-type-label');
                if (typeLabelEl) typeLabelEl.textContent = '';
                // render first question
                showQuestion();
            });
        }

        // Restart behavior: show start screen again and reset state
        restartBtn.addEventListener('click', () => {
            // reset state
            // cleanup persistent fireworks if any
            try {
                if (persistentFireworksCleanup) {
                    persistentFireworksCleanup();
                    persistentFireworksCleanup = null;
                }
            } catch (e) { /* ignore */ }
            questions = [];
            current = 0;
            score = 0;
            // hide game, show start
            gameArea.style.display = 'none';
            startScreen.style.display = 'flex';
            // cleanup UI
            questionEl.textContent = '';
            answersEl.innerHTML = '';
            resultEl.textContent = '';
            const finalBtn = document.getElementById('final-answer-btn');
            if (finalBtn) finalBtn.remove();
            const nextBtn = document.getElementById('next-btn');
            if (nextBtn) nextBtn.remove();
            renderLadder(0);
        });

        // simple fireworks overlay (canvas) — auto-removes after duration
        function showFireworks(duration = 2500, persist = false) {
            const canvas = document.createElement('canvas');
            canvas.style.position = 'fixed';
            canvas.style.left = '0';
            canvas.style.top = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = 9999;
            document.body.appendChild(canvas);
            const ctx = canvas.getContext('2d');
            function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
            resize();
            window.addEventListener('resize', resize);

            let particles = [];
            function rnd(min, max) { return Math.random() * (max - min) + min; }
            const colors = ['#ff5252','#ffea00','#69f0ae','#448aff','#ff4081','#ffb74d'];

            function spawnBursts(countBursts = 4) {
                for (let b = 0; b < countBursts; b++) {
                    const cx = rnd(canvas.width * 0.15, canvas.width * 0.85);
                    const cy = rnd(canvas.height * 0.1, canvas.height * 0.45);
                    const count = 20 + Math.floor(Math.random() * 40);
                    for (let i = 0; i < count; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = rnd(1.5, 7);
                        particles.push({
                            x: cx,
                            y: cy,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: rnd(700, 1600),
                            age: 0,
                            color: colors[Math.floor(Math.random() * colors.length)],
                            size: rnd(1.5, 3.5)
                        });
                    }
                }
            }

            // initial bursts
            spawnBursts(6);

            // If persistent, keep spawning new bursts periodically until cleanup is called
            let spawnInterval = null;
            if (persist) {
                spawnInterval = setInterval(() => {
                    // spawn a few bursts to keep the effect alive
                    spawnBursts(3);
                }, 800 + Math.floor(Math.random() * 800));
            }

            let last = performance.now();
            let running = true;
            function frame(now) {
                if (!running) return;
                const dt = now - last; last = now;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // update and draw particles
                for (let p of particles) {
                    p.age += dt;
                    if (p.age >= p.life) continue;
                    const t = p.age / p.life;
                    p.vy += 0.002 * dt;
                    p.x += p.vx * dt / 16;
                    p.y += p.vy * dt / 16;
                    ctx.globalAlpha = Math.max(0, 1 - t);
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * (1 + t), 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                // remove dead particles to keep array small
                particles = particles.filter(p => p.age < p.life);

                // If not persistent and no particles remain, cleanup
                if (!persist && particles.length === 0) {
                    cleanup();
                    return;
                }
                // continue animation
                requestAnimationFrame(frame);
            }

            function cleanup() {
                running = false;
                window.removeEventListener('resize', resize);
                if (spawnInterval) {
                    clearInterval(spawnInterval);
                    spawnInterval = null;
                }
                if (canvas && canvas.parentNode) canvas.parentNode.removeChild(canvas);
            }

            requestAnimationFrame(frame);

            // If not persistent, schedule a safety cleanup after duration
            if (!persist) {
                setTimeout(() => { try { cleanup(); } catch (e) {} }, duration + 300);
                return cleanup;
            }
            // persistent: return cleanup so caller can remove when desired
            return cleanup;
        }

        // Developer helper: click the $1,000,000 ladder entry to mark the current question correct
        function devWinMillion() {
            try {
                if (!questions || current >= questions.length) return;
                const q = questions[current];
                const correctIdx = q.correct;
                // try to find the visible answer button for the correct answer
                let btn = answersEl.children[correctIdx];
                if (!btn) btn = document.createElement('button');
                // trigger the normal check flow (this will show fireworks, result text, etc.)
                checkAnswerWithEffect(correctIdx, btn);
                const isFinal = (current === questions.length - 1);
                // If not the final question, advance automatically after a short delay
                if (!isFinal) {
                    setTimeout(() => {
                        // emulate clicking Next: increase score and move on
                        score++;
                        current++;
                        const nextBtn = document.getElementById('next-btn');
                        if (nextBtn) nextBtn.remove();
                        showQuestion();
                    }, 600);
                }
            } catch (e) { /* ignore developer helper errors */ }
        }

        function showQuestion() {
            if (current < questions.length) {
                const q = questions[current];
                questionEl.textContent = q.question;
                answersEl.innerHTML = '';
                let selectedIdx = null;
                let finalBtn = document.getElementById('final-answer-btn');
                if (finalBtn) finalBtn.remove();
                // Render answer buttons
                q.answers.forEach((ans, idx) => {
                    const btn = document.createElement('button');
                    btn.textContent = ans;
                    btn.disabled = false; // ensure enabled
                    btn.onclick = () => {
                        Array.from(answersEl.children).forEach((b, i) => {
                            b.classList.remove('selected');
                            b.style.background = ''; // allow .selected CSS to show yellow
                        });
                        btn.classList.add('selected');
                        selectedIdx = idx;
                        if (!document.getElementById('final-answer-btn')) {
                            const finalBtn = document.createElement('button');
                            finalBtn.id = 'final-answer-btn';
                            finalBtn.textContent = 'Final answer?';
                            finalBtn.onclick = () => {
                                if (selectedIdx !== null) {
                                    checkAnswerWithEffect(selectedIdx, btn);
                                }
                            };
                            answersEl.parentNode.insertBefore(finalBtn, answersEl.nextSibling);
                        }
                    };
                    answersEl.appendChild(btn);
                });
                resultEl.textContent = '';
                restartBtn.style.display = 'none';
                let nextBtn = document.getElementById('next-btn');
                if (nextBtn) nextBtn.remove();
                // render ladder based on current score
                renderLadder(score);
                // Show question label at bottom (moved out of .quiz-container)
                let labelIdx = q.typeIdx !== undefined ? q.typeIdx : (typeof q.type === 'number' ? q.type : null);
                let label = labelIdx !== null ? questionTypes[labelIdx] : '';
                const typeLabelEl = document.getElementById('question-type-label');
                if (typeLabelEl) {
                    typeLabelEl.textContent = label;
                    typeLabelEl.style.color = '#fff';
                }
            } else {
                showResult();
            }
        }
        function renderLadder(achievedCount) {
            // achievedCount = number of correctly answered questions (score)
            ladderEl.innerHTML = '';
            for (let i = prizeLadder.length - 1; i >= 0; i--) {
                const li = document.createElement('li');
                li.textContent = `$${prizeLadder[i].toLocaleString()}`;
                if (i === 4 || i === 9) li.classList.add('safetynet');
                if (i === 14) li.classList.add('million');
                // Make the million item clickable for developer testing
                if (i === 14) {
                    li.style.cursor = 'pointer';
                    li.title = 'DEV: Click to auto-answer current question correctly';
                    li.addEventListener('click', (ev) => {
                        ev.preventDefault();
                        devWinMillion();
                    });
                }
                // i ranges 14..0, achieved indices are 0..achievedCount-1
                if (i < achievedCount) {
                    li.classList.add('achieved');
                } else if (i === achievedCount) {
                    li.classList.add('current');
                }
                ladderEl.appendChild(li);
            }
        }

        function showQuestion() {
            if (current < questions.length) {
                const q = questions[current];
                questionEl.textContent = q.question;
                answersEl.innerHTML = '';
                let selectedIdx = null;
                let finalBtn = document.getElementById('final-answer-btn');
                if (finalBtn) finalBtn.remove();
                // Render answer buttons
                q.answers.forEach((ans, idx) => {
                    const btn = document.createElement('button');
                    btn.textContent = ans;
                    btn.disabled = false; // ensure enabled
                    btn.onclick = () => {
                        Array.from(answersEl.children).forEach((b, i) => {
                            b.classList.remove('selected');
                            b.style.background = ''; // allow .selected CSS to show yellow
                        });
                        btn.classList.add('selected');
                        selectedIdx = idx;
                        if (!document.getElementById('final-answer-btn')) {
                            const finalBtn = document.createElement('button');
                            finalBtn.id = 'final-answer-btn';
                            finalBtn.textContent = 'Final answer?';
                            finalBtn.onclick = () => {
                                if (selectedIdx !== null) {
                                    checkAnswerWithEffect(selectedIdx, btn);
                                }
                            };
                            answersEl.parentNode.insertBefore(finalBtn, answersEl.nextSibling);
                        }
                    };
                    answersEl.appendChild(btn);
                });
                resultEl.textContent = '';
                restartBtn.style.display = 'none';
                let nextBtn = document.getElementById('next-btn');
                if (nextBtn) nextBtn.remove();
                // render ladder based on current score
                renderLadder(score);
                // Show question label at bottom (moved out of .quiz-container)
                let labelIdx = q.typeIdx !== undefined ? q.typeIdx : (typeof q.type === 'number' ? q.type : null);
                let label = labelIdx !== null ? questionTypes[labelIdx] : '';
                const typeLabelEl2 = document.getElementById('question-type-label');
                if (typeLabelEl2) {
                    typeLabelEl2.textContent = label;
                    typeLabelEl2.style.color = '#fff';
                }
            } else {
                // End of questions — show final summary and Restart button
                questionEl.textContent = '';
                answersEl.innerHTML = '';
                renderLadder(score);
                resultEl.innerHTML = `You reached question ${current} out of ${questions.length}.<br>Your score: $${score * 1000}`;
                restartBtn.className = 'restart custom-next-btn';
                restartBtn.style.display = 'inline-block';
            }
        }

        // Helper: flash correct button green in pulses (pulses within totalMs), then call cb
        function flashGreenPulses(btn, pulses, totalMs, cb) {
            // Use explicit colors: green for pulse, yellow if selected, white otherwise
            const isSelected = btn.classList.contains('selected');
            const origBg = isSelected ? '#ffd600' : '#fff';
            const prevTransition = btn.style.transition || '';
            // Temporarily disable background transition so pulses are instant
            btn.style.transition = 'none';
            const singlePeriod = Math.floor(totalMs / pulses);
            const onMs = Math.max(80, Math.floor(singlePeriod * 0.35)); // green on duration
            const offMs = Math.max(50, singlePeriod - onMs);
            let i = 0;
            function doPulse() {
                if (i >= pulses) {
                    btn.style.background = '#43a047';
                    // restore transition
                    btn.style.transition = prevTransition;
                    if (cb) cb();
                    return;
                }
                // paint green, force repaint, then restore to selected/orig color
                btn.style.background = '#43a047';
                // force repaint
                void btn.offsetWidth;
                setTimeout(() => {
                    btn.style.background = origBg;
                    // force repaint
                    void btn.offsetWidth;
                    i++;
                    setTimeout(doPulse, offMs);
                }, onMs);
            }
            doPulse();
        }

        function checkAnswerWithEffect(idx, btn) {
            let finalBtn = document.getElementById('final-answer-btn');
            if (finalBtn) finalBtn.remove();
            const correctIdx = questions[current].correct;
            const answerButtons = Array.from(answersEl.children);
            // prevent interactions by removing pointer events
            answerButtons.forEach((b) => {
                b.style.pointerEvents = 'none';
            });

            // helper to compute guaranteed prize when the player fails
            function guaranteedPrizeForScore(s) {
                if (s >= 10) return prizeLadder[9]; // passed question 10
                if (s >= 5) return prizeLadder[4];  // passed question 5
                return 0;
            }

            if (idx === correctIdx) {
                // Immediately mark ladder current as achieved
                const liIndex = prizeLadder.length - 1 - score;
                const currentLi = ladderEl.children[liIndex];
                if (currentLi) {
                    currentLi.classList.remove('current');
                    currentLi.classList.add('achieved');
                }
                // ensure selected visual is present
                btn.classList.add('selected');
                // turn correct answer green
                btn.classList.add('correct');

                // if this is question 5, 10 or 15 (indices 4,9,14) show fireworks
                const isMilestone = (current === 4 || current === 9 || current === 14);
                if (isMilestone) {
                    try {
                        // persist fireworks only for the final win (index 14)
                        const cleanup = showFireworks(2500, current === 14);
                        if (current === 14) {
                            // store cleanup to remove on restart
                            persistentFireworksCleanup = cleanup;
                        }
                    } catch (e) { /* ignore animation errors */ }
                }

                const isFinalQuestion = (current === questions.length - 1);
                if (isFinalQuestion) {
                    // On the final question, tell the user the prize amount
                    const prizeAmount = prizeLadder[score].toLocaleString();
                    resultEl.textContent = `🎉 Correct! Well done! You won $${prizeAmount}!`;
                } else {
                    // On non-final questions, do not show the prize amount — simple congrat
                    resultEl.textContent = '🎉 Correct! Well done!';
                }

                if (isFinalQuestion) {
                    // Show restart button for final correct — use existing restart handler
                    restartBtn.className = 'restart custom-next-btn';
                    restartBtn.style.display = 'inline-block';
                } else {
                    let nextBtn = document.createElement('button');
                    nextBtn.id = 'next-btn';
                    nextBtn.textContent = 'Next';
                    nextBtn.className = 'custom-next-btn';
                    nextBtn.onclick = () => {
                        // advance after acknowledging
                        score++;
                        current++;
                        nextBtn.remove();
                        if (current < questions.length) showQuestion(); else {
                            // End of questions — show final summary and Restart button
                            questionEl.textContent = '';
                            answersEl.innerHTML = '';
                            renderLadder(score);
                            resultEl.innerHTML = `You reached question ${current} out of ${questions.length}.<br>Your score: $${score * 1000}`;
                            restartBtn.className = 'restart custom-next-btn';
                            restartBtn.style.display = 'inline-block';
                        }
                    };
                    resultEl.parentNode.insertBefore(nextBtn, resultEl.nextSibling);
                }
            } else {
                // incorrect: mark chosen red and correct green
                btn.classList.add('incorrect');
                if (answerButtons[correctIdx]) answerButtons[correctIdx].classList.add('correct');
                // compute guaranteed prize based on safety nets
                const finalPrize = guaranteedPrizeForScore(score);
                const prizeText = finalPrize > 0 ? `$${finalPrize.toLocaleString()}` : '$0';
                resultEl.textContent = `Not quite. You won ${prizeText}. Try again next time!`;
                restartBtn.className = 'restart custom-next-btn';
                restartBtn.style.display = 'inline-block';
            }
        }
    </script>
</body>
</html>
